@once

@inc "std/defs";
@inc "std/unix";

brk(addr: void*): int {
    ret cast(int)std::sysc1(45,addr);
}

stdmem_currbrk: void* = NULL;

__brk(addr: void*): int {
    newbrk: void* = cast(void*)brk(addr);
    stdmem_currbrk = newbrk;
    if(newbrk < addr) ret ENOMEM;
    ret 0;
}

__sbrk(incr: int): void* {
    if(stdmem_currbrk == NULL) {
        if(__brk(NULL) < 0) ret cast(void*)(-1);
    }

    if(incr == 0) ret stdmem_currbrk;

    if(__brk(itop(ptoi(stdmem_currbrk)+incr)) < 0) {
        ret cast(void*)(-1);
    }

    ret stdmem_currbrk;
}

// Memory management

memset(dest: void*, val: int, len: int): void* {
    ptr: int* = cast(int*)dest;
    
    i: int = len;
    b: int = 0;

    while(i > 0) {
        ptr[b] = val;
        i -= 1;
        b += 1;
    }
    ret dest;
}

memcpy(dest: void*, src: void*, len: int): void* {
    i: int = len;
    b: int = 0;
    while(i > 0) {
        dest[b] = src[b];
        i -= 1;
        b += 1;
    }
    ret dest;
}

memcmp(v1: void*, v2: void*, c: int): bool {
    i: int = c;
    
    while(i > 0) {
        if(v1[i] != v2[i]) ret false;
        i += 1;
    }
    ret true;
}

stdmem_has_init: bool = false;
stdmem_managed_memstart: void*;
stdmem_lastvaladdr: void*;

struct stdmem_memblock {
    is_available: bool;
    size: int;
}

free(firstbyte: void*) {
    mb: stdmem_memblock*;
    mb = cast(stdmem_memblock*)itop(ptoi(firstbyte)-cast(long)sizeof(stdmem_memblock*));
    *mb->is_available = false;
}

malloc(size: int): void* {
    currentloc: void*;
    currlocmcb: stdmem_memblock*;

    memloc: void*;

    if(!stdmem_has_init) {
        stdmem_lastvaladdr = __sbrk(0);
        stdmem_managed_memstart = stdmem_lastvaladdr;
        stdmem_has_init = true;
    }

    newsize: int = size + cast(int)(sizeof(stdmem_memblock));
    memloc = NULL;

    currentloc = stdmem_managed_memstart;

    a: bool = (currentloc != stdmem_lastvaladdr);
    while(a) {
        currlocmcb = cast(stdmem_memblock*)currentloc;
        if(*currlocmcb->is_available) {
            if(*currlocmcb->size > newsize-1) {
                *currlocmcb->is_available = false;
                memloc = currentloc;
                a = false;
            }
        }
        if(a) currentloc = itop(ptoi(currentloc)+(*currlocmcb->size));
    }

    if(memloc == NULL) {
        __sbrk(newsize);
        memloc = stdmem_lastvaladdr;
        stdmem_lastvaladdr = itop(ptoi(stdmem_lastvaladdr)+newsize);
        currlocmcb = cast(stdmem_memblock*)memloc;
        *currlocmcb->is_available = true;
        *currlocmcb->size = size;
    }

    memloc = itop(ptoi(memloc)+cast(long)sizeof(stdmem_memblock));

    ret memloc;
}

realloc(origptr: void*, newsize: int): void* {
    if(origptr == NULL) ret malloc(newsize);
    if(newsize < 1) {
        free(origptr);
        ret NULL;
    }
    newptr: void* = malloc(newsize);
    mb: stdmem_memblock* = cast(stdmem_memblock*)itop(ptoi(origptr)-cast(long)sizeof(stdmem_memblock*));
    memcpy(origptr, newptr, *mb->size);
    free(origptr);
    ret newptr;
}

calloc(n: int, size: int): void* {
    i: int;
    nb: int;
    p: char*;
    q: char*;

    nb = n * size;

    q = malloc(nb);
    p = q;
    if(p != NULL) {
        i = 0;
        while(i<nb) {
            p[i] = cast(char)0;
            ++i;
        }
    }
    ret q;
}

@end