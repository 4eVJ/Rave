import <std/io>

namespace std {
    namespace map {
        struct Entry {
            void* key;
            void* value;
            std::map::Entry* next;
        }
    }

    alias mapSize = 32;

    int hash(void* data, int size) {
        return = 5381;
        int idx = 0;

        while(idx < size) {
            return = ((return <. 5) + return) + data[idx];
            idx += 1;
        }

        if(return < 0) return = -return;
    } => return % std::mapSize;

    struct map<K, V> {
        std::map::Entry** table;
        int length;

        std::map<K, V> this {
            std::map<K, V> this;
            this.length = 0;
            this.table = cast(std::map::Entry**)std::malloc(sizeof(std::map::Entry*) * std::mapSize);
            for(int i=0; i<std::mapSize; i++) this.table[i] = null;
        } => this;

        void set(K key, V value) {
            uint index = std::hash(cast(void*)&key, sizeof(K));

            std::map::Entry* entry = table[index];
            bool setted = false;
            while(entry != null) {
                if(key == cast(K)(entry.key)) {
                    entry.value = cast(void*)value;
                    setted = true;
                    break;
                }
                entry = entry.next;
            }

            if(!setted) {
                table[index] = cast(std::map::Entry*)std::malloc(sizeof(std::map::Entry));
                table[index].key = cast(void*)key;
                table[index].value = cast(void*)value;
            }
        }

        V get(K key) {
            return = cast(V)null;
            uint index = std::hash(cast(void*)&key, sizeof(K));

            std::map::Entry* entry = table[index];

            while(entry != null) {
                if((cast(K)(entry.key)) == key) {
                    return = (cast(V)(entry.value));
                    break;
                }
                else entry = entry.next;
            }
        }

        void ~this {
            if(this.table != null) {
                for(int i=0; i<std::mapSize; i++) {
                    if(this.table[i] != null) std::free(cast(void*)(this.table[i]));
                }
                std::free(cast(void*)(this.table));
                this.table = null;
            }
        }
    }
}