import <std/vector>

namespace std {
  namespace math {
    alias PI = 3.14159265358979323846;

    (inline) float degToRad(float d) => d * std::math::PI / 180;
    (inline) float radToDeg(float r) => r * 180 / std::math::PI;

    int factorial(int n) {
        int fact = 1;
        int i = 1;
        while(i <= n) {
            fact = fact * i;
            i += 1;
        }
    } => fact;

    float abs(float f) {
        float result = f;
        if(f < 0.0) result = -result;
    } => result;

    extern(linkname: "acosf") float acos(float f);
    extern(linkname: "acoshf") float acosh(float f);
    extern(linkname: "asinf") float asin(float f);
    extern(linkname: "asinhf") float asinh(float f);
    extern(linkname: "atanf") float atan(float f);
    extern(linkname: "atanhf") float atanh(float f);
    extern(linkname: "cbrtf") float cbrt(float f);
    extern(linkname: "ceilf") float ceil(float f);
    extern(linkname: "cosf") float cos(float f);
    extern(linkname: "coshf") float cosh(float f);
    extern(linkname: "erff") float erf(float f);
    extern(linkname: "exp2") float exp2(float f);
    float pow(float f, float f2) {
        float result;
        if(f2 < 0) {
            result = 1 / std::math::pow(f,-f2);
        }
        else {
            float r = 1.0;
            while(f2 > 0) {
                r = r * f;
                f2 = f2 - 1;
            }
            if(f2 > 0) {
                r = r * f * f2;
            }
            result = r;
        }
    } => result;
    double pow(double f, double f2) {
        double result;
        if(f2 < 0) {
            result = 1 / std::math::pow(f,-f2);
        }
        else {
            double r = 1.0;
            while(f2 > 0) {
                r = r * f;
                f2 = f2 - 1;
            }
            if(f2 > 0) {
                r = r * f * f2;
            }
            result = r;
        }
    } => result;
    char sign(float x) {
        char result = 0;
        if(x < 0) result = -1;
        else if(x == 0) result = 0;
        else if(x > 0) result = 1;
    } => result;
    float floor(float f) {
        float tmp = (cast(float)(cast(long)f));
        if(tmp < 0) tmp = tmp - 1.0;
    } => tmp;
    double min(double one, double two) {
        double result = one;
        if(two < one) result = two;
    } => result;
    int min(int one, int two) {
        int result = one;
        if(two < one) result = two;
    } => result;
    double max(double one, double two) {
        double result = one;
        if(two > one) result = two;
    } => result;
    int max(int one, int two) {
        int result = one;
        if(two > one) result = two;
    } => result;

    extern(linkname: "sinf") float sin(float f);

    double sqrt(double d) {
        double result = 1.0;
        for(int i=0; i<=10; i+=1) {
            result = result - (result * result - d) / (2 * result);
        }
    } => result;

    float mod(float x) {
        float result = 1.0;
        if((x % 1.0) != 0.0) {
            result = (x % 1.0);
        }
    } => result;

    float round(float x, int n) {
        x = x * std::math::pow(10.0,cast(float)n);
        x += 0.5;
        x = std::math::floor(x) / std::math::pow(10.0,cast(float)n);
    } => x;

    bool isPrime(int number) {
        bool toret = true;
        int i = 2;

        bool active = true;
        while((i<number) && active) {
            if((number % i == 0) && (i != number)) {
                toret = false;
                active = false;
            }
            i += 1;
        }
    } => toret;

    int nextPrime(int number) {
        int n = number;
        while(!(std::math::isPrime(n))) n += 1;
    } => n;
  }
}
