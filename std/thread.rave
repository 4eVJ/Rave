import <std/process>

@if(__RAVE_OS != "WINDOWS") {
    import <std/pthread>
    struct thread {
        ulong id;

        std::thread this {
            std::thread this;
            this.id = 0;
        } => this;

        void run(void*(void*) fn, void* argument) {
            pthread::create(this.&id, cast(pthread::attribute*)null, fn, argument);
        }

        int join(void** valuePtr) => pthread::join(this.id, valuePtr);

        int join {this.join(cast(void**)null);}
    }
};

@if(__RAVE_OS == "LINUX") {
    namespace std {
        namespace thread {
            alias cloneVM = 256;
            alias cloneFS = 512;
            alias cloneFiles = 1024;
            alias cloneSighand = 2048;
            alias cloneThread = 65536;
            alias cloneSysvsem = 262144;
            alias cloneSetTLS = 524288;
            alias cloneParentSetTID = 1048576;
            alias cloneChildClearTID = 2097152;

            (inline) int getCurrentID => cast(int)std::syscall(std::sysctable::GetTID);
            (inline) int __wait4(int pid, int* wstatus, int options, void* rusage) => cast(int)std::syscall(std::sysctable::Wait4, pid, wstatus, options, rusage);
            (inline) int __waitpid(int pid, int* status, int options) => std::thread::__wait4(pid, status, options, null);
        }
    }
};

namespace std {
    namespace thread {
        namespace spinlock {
            (inline) void lock(int* sl) {while(@atomicTAS(sl, 1) == 1) {}}
            (inline) void unlock(int* sl) {@atomicClear(sl);}
        }
    }
}