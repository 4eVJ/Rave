namespace std {
    extern(linkname: "malloc") void* malloc(int size);
    extern(linkname: "free") void free(void* ptr);
    extern(linkname: "realloc") void* realloc(void* ptr, int newsize);
    extern(linkname: "memcpy") void* memcpy(void* dest, void* src, int n);
    extern(linkname: "memmove") void* memmove(void* dest, void* src, int n);
    extern(linkname: "memcmp") bool memcmp(void* one, void* two, int n);
    extern(linkname: "memset") void* memset(void* dest, int val);
    extern(linkname: "calloc") void* calloc(int num, int size);
    extern(linkname: "llvm.frameaddress.p0i8") void* frameAddress(int level);
    extern(linkname: "llvm.eh.sjlj.setjmp") int setjmp(char* buff);

    struct pair<T,TT> {
        T first;
        TT second;

        std::pair<T,TT> this(T first, TT second) {
            this.first = first;
            this.second = second;
        } => this;

        bool operator==(std::pair<T,TT> f, std::pair<T,TT> s) => (f.first == s.first) && (f.second == s.second);
        bool operator!=(std::pair<T,TT> f, std::pair<T,TT> s) => !(f == s);
        std::pair<T,TT> operator+(std::pair<T,TT> f, std::pair<T,TT> s) {
            std::pair<T,TT> copy = std::pair<T,TT>(f.first,f.second);
            copy.first += s.first;
            copy.second += s.second;
        } => copy;
    }
}

macro delete {
    std::free(cast(void*)#0);
}

macro new {
    return cast(@baseType(#0)*)std::malloc(sizeof(#0));
}