namespace std {
    extern(linkname: "malloc") void* malloc(int size);
    extern(linkname: "free") void free(void* ptr);

    int rSl;
    void* realloc(void* ptr, int oldsize, int newsize) {
        while(@atomicTAS(&std::rSl, 1) == 1) {}
            void* newptr = std::malloc(newsize);
            @if((__RAVE_RUNTIME_CHECKS) && (__RAVE_OPTIMIZATION_LEVEL == 0)) {
                std::assert(newptr != null, "Pointer into realloc is null!");
            };
            for(int i=0; i<oldsize; i++) newptr[i] = ptr[i];
            std::free(ptr);
        @atomicClear(&std::rSl);
    } => newptr;

    (inline) void* calloc(int num, int size) => std::malloc(num * size);

    char[2048] __space;
    int __position;

    (nochecks) void* alignAlloc(int size, int alignment) {
        int* alignedAddr = cast(int*)(ptoi(&std::__space) + std::__position + alignment - 1) && (!(alignment - 1));

        // Check if there is enough space in the buffer
        if(ptoi(alignedAddr) + size > ptoi(&std::__space) + 2048) @return(std::malloc(size));

        // Update the buffer position
        std::__position = ptoi(alignedAddr) + size - ptoi(&std::__space);
    } => cast(void*)alignedAddr;

    // Use alignAlloc with default alignment of 4 bytes
    (inline) void* alloc(int size) => std::alignAlloc(size, 4);

    (inline) void afree(void* ptr) {
        if(((ptr < &std::__space) || (ptr > itop(char*, ptoi(&std::__space) + 2048)))) std::free(ptr);
    }
}

namespace std {
    (nochecks) void* memcpy(void* dest, void* src, int n) {
        for(int i=0; i<n; i+=1) dest[i] = src[i];
    } => dest;

    (nochecks) void* memmove(void* dest, void* src, int n) {
        void* temp = std::malloc(n);
        for(int i=0; i<n; i+=1) temp[i] = src[i];
        for(int i=0; i<n; i+=1) dest[i] = temp[i];
        std::free(temp);
    } => dest;

    (nochecks) bool memcmp(void* one, void* two, int n) {
        return = true;
        for(int i=0; i<n; i+=1) {
            if(one[i] != two[i]) {
                return = false;
                break;
            }
        }
    }

    (nochecks) void* memset(void* dest, int c, int n) {
        for(int i=0; i<n; i+=1) dest[i] = cast(char)c;
    } => dest;

    extern(linkname: "llvm.frameaddress.p0i8") void* frameAddress(int level);
    extern(linkname: "llvm.eh.sjlj.setjmp") int setjmp(char* buff);

    struct pair<P1, P2> {
        P1 first;
        P2 second;

        std::pair<P1, P2> this(P1 first, P2 second) {
            std::pair<P1, P2> this;
            this.first = first;
            this.second = second;
        } => this;
    }
}
