import <std/math>

namespace std {
    alias TagNone = cast(char)0x0;
    alias TagRoot = cast(char)0x1;
    alias TagMark = cast(char)0x2;

    int gcHash(void* ptr) => (cast(int)ptr) >> 3;
    void* mcalloc(int c, int s) {
        void* toret;
        if(c == 0) toret = std::malloc(s);
        else toret = std::calloc(c,s);
    } => toret;

    struct Alloc {
        void* ptr;
        int size;
        char tag;
        void() dtor;
        std::Alloc* next;

        std::Alloc* this(void* ptr, int size, void() dtor) {
            this.ptr = ptr;
            this.size = size;
            this.tag = std::TagNone;
            this.dtor = dtor;
            this.next = cast(std::Alloc*)null;
        } => this;
    }
    struct AllocMap {
        int cap;
        int minCap;
        float downSizeFactor;
        float upSizeFactor;
        float sweepFactor;
        int sweepLimit;
        int size;
        std::Alloc** allocations;

        std::AllocMap* this(int cap, int minCap, float swF, float dsF, float upsF) {
            this.minCap = std::nextPrime(minCap);
            this.cap = std::nextPrime(cap);

            if(this.cap < this.minCap) this.cap = this.minCap;

            this.sweepFactor = swF;
            this.sweepLimit = cast(int)(swF*this.cap);
            this.downSizeFactor = dsF;
            this.upSizeFactor = upsF;
            this.allocations = cast(std::Alloc**)std::calloc(this.cap,sizeof(std::Alloc*));
            this.size = 0;
        } => this;

        float loadFactor => (cast(float)this.size / cast(float)this.cap);

        void resize(int newCap) {
            if(newCap > this.minCap) {
                std::Alloc** resizedAllocations = cast(std::Alloc**)std::calloc(newCap,sizeof(std::Alloc*));
                
                int i = 0;
                while(i<this.cap) {
                    std::Alloc* alloc = this.allocations[i];

                    while(alloc != cast(std::Alloc*)null) {
                        std::Alloc* next = alloc.next;
                        int newIndex = std::gcHash(alloc.ptr) % newCap;
                        alloc.next = resizedAllocations[newIndex];
                        resizedAllocations[newIndex] = alloc;
                        alloc = next;
                    }
                    i += 1;
                }
                std::free(this.allocations);
                this.cap = newCap;
                this.allocations = resizedAllocations;
                this.sweepLimit = cast(int)(this.size + this.sweepFactor * (this.cap - this.size));
            }
        }

        bool resizeToFit {
            bool toret = false;

            float loadF = this.loadFactor();
            if(loadF > this.upSizeFactor) {
                this.resize(std::nextPrime(this.cap * 2));
                toret = true;
            }
            if(loadF < this.downSizeFactor) {
                this.resize(std::nextPrime(this.cap / 2));
                toret = true;
            }
        } => toret;

        std::Alloc* get(void* ptr) {
            int index = std::gcHash(ptr) % this.cap;
            std::Alloc* curr = this.allocations[index];

            std::Alloc* toret = cast(std::Alloc*)null;

            bool _disable = false;

            while((curr != cast(std::Alloc*)curr) && (!_disable)) {
                if(curr.ptr == ptr) {
                    toret = curr;
                    _disable = true;
                }
                else curr = curr.next;
            }
        } => toret;

        std::Alloc* put(void* ptr, int size, void() dtor) {
            int index = std::gcHash(ptr) % this.cap;
            std::Alloc* alloc = std::Alloc(ptr,size,dtor);
            std::Alloc* curr = this.allocations[index];
            std::Alloc* prev = cast(std::Alloc*)null;
            
            bool _disable = false;

            while((curr != cast(std::Alloc*)null) && (!_disable)) {
                if(curr.ptr == ptr) {
                    alloc.next = curr.next;

                    if(prev == cast(std::Alloc*)null) this.allocations[index] = alloc;
                    else prev.next = alloc;

                    ~curr;
                    _disable = true;
                }
                prev = curr;
                curr = curr.next;
            }
            if(!_disable) {
                curr = this.allocations[index];
                alloc.next = curr;
                this.allocations[index] = alloc;
                this.size += 1;

                void* p = alloc.ptr;
                if(this.resizeToFit()) {
                    alloc = this.get(p);
                }
            }
        } => alloc;

        void remove(void* ptr, bool allowResize) {
            int index = std::gcHash(ptr) % this.cap;

            std::Alloc* curr = this.allocations[index];
            std::Alloc* prev = cast(std::Alloc*)null;
            std::Alloc* next;

            while(curr != cast(std::Alloc*)null) {
                next = curr.next;
                if(curr.ptr == ptr) {
                    if(prev == cast(std::Alloc*)null) this.allocations[index] = curr.next;
                    else prev.next = curr.next;
                }
                else prev = curr;
                curr = next;
            }
            if(allowResize) this.resizeToFit();
        }

        void ~this {
            std::Alloc* alloc;
            std::Alloc* temp;

            int i = 0;
            while(i<this.cap) {
                alloc = this.allocations[i];
                if(alloc != cast(std::Alloc*)null) {
                    while(alloc != cast(std::Alloc*)null) {
                        temp = alloc;
                        alloc = alloc.next;
                        ~temp;
                    }
                }
                i += 1;
            }

            std::free(this.allocations);
        }
    }
    struct GC {
        std::AllocMap* allocations;
        void* bos;
        int minSize;
        bool paused;

        std::GC* this(void* bos) {
            this.paused = false;
            this.bos = bos;

            this.allocations = std::AllocMap(1024,1024,0.5,0.2,0.8);
        } => this;

        bool needsSwep => (this.allocations.size > this.allocations.sweepLimit);

        void markAlloc(void* ptr) {
            std::Alloc* alloc = this.allocations.get(ptr);

            if((alloc != cast(std::Alloc*)null) && (!(alloc.tag && std::TagMark)) == cast(int)true) {
                alloc.tag = alloc.tag || std::TagMark;

                char* p = cast(char*)alloc.ptr;
                while((cast(int)p) <= ((cast(int)alloc.ptr) + alloc.size - sizeof(char*))) {
                    this.markAlloc(cast(void**)p[0]);
                    p = cast(char*)((cast(int)p)+1);
                }
            }
        }

        void markStack {
            void* tos = std::frameAddress(0);
            void* bos = this.bos;

            char* p = cast(char*)tos;

            while((cast(int)p) <= ((cast(int)bos)-sizeof(char*))) {
                this.markAlloc(cast(void**)p[0]);
            }

            volatile void(std::GC*) _markStack = this.markStack;

            char[5] ctx;
            std::memset(&ctx,0);
            std::setjmp(&ctx);
            _markStack(this);
        }

        void markRoots {
            int i = 0;
            while(i<this.allocations.cap) {
                std::Alloc* chunk = this.allocations.allocations[i];
                while(chunk != cast(std::Alloc*)null) {
                    if((chunk.tag && std::TagRoot) == cast(int)true) this.markAlloc(chunk.ptr);
                }
                chunk = chunk.next;
                i += 1;
            }
        }

        void mark {
            this.markRoots();

            volatile void(std::GC*) _markStack = this.markStack;

            _markStack(this);
        }

         int sweep {
            int total = 0;

            int i = 0;
            while(i<this.allocations.cap) {
                std::Alloc* chunk = this.allocations.allocations[i];
                std::Alloc* next = cast(std::Alloc*)null;

                while(chunk != cast(std::Alloc*)null) {
                    if((chunk.tag && std::TagMark) == cast(int)true) {
                        chunk.tag = chunk.tag && (!(std::TagMark));
                    }
                    else {
                        total += chunk.size;
                        if(chunk.dtor != cast(void())null) {
                            chunk.dtor();
                        }
                        std::free(chunk.ptr);
                        next = chunk.next;
                        this.allocations.remove(chunk.ptr,false);
                        chunk = next;
                    }
                }

                i += 1;
            }
            this.allocations.resizeToFit();
        } => total;

        int run {
            this.mark();
        } => this.sweep();

        void* allocate(int c, int s, void() dtor) {
            if(this.needsSwep() && !(this.paused)) {
                int freed_mem = this.run();
            }

            void* ptr = std::mcalloc(c,s);
            int allocSize = s;
            if(c > 0) allocSize = allocSize * c;
            
            if(((ptr == null) && (!(this.paused)))) {
                this.run();
                ptr = std::mcalloc(c,s);
            }

            if(ptr != null) {
                std::Alloc* alloc = this.allocations.put(ptr,allocSize,dtor);
                
                if(alloc != null) ptr = alloc.ptr;
                else {
                    std::free(ptr);
                    ptr = null;
                }
            }
        } => ptr;

        void makeRoot(void* ptr) {
            std::Alloc* alloc = this.allocations.get(ptr);
            if(alloc != null) alloc.tag = alloc.tag || std::TagRoot;
        }
        
        void pause {
            this.paused = true;
        }

        void resume {
            this.paused = false;
        }

        void stop {
            int i = 0;
            while(i<this.allocations.cap) {
                std::Alloc* chunk = this.allocations.allocations[i];
                
                while(chunk != cast(std::Alloc*)null) {
                    if((chunk.tag && std::TagRoot) == cast(int)true) {
                        chunk.tag = chunk.tag && (!(std::TagRoot));
                    }
                    chunk = chunk.next;
                }

                i += 1;
            }
            int collected = 0;

            i = 0;
            while(i<this.allocations.cap) {
                std::Alloc* chunk = this.allocations.allocations[i];
                std::Alloc* next = cast(std::Alloc*)null;

                while(chunk != cast(std::Alloc*)null) {
                    if((chunk.tag && std::TagMark) == cast(int)true) {
                        chunk.tag = chunk.tag && (!(std::TagMark));
                    }
                    else {
                        collected += chunk.size;
                        if(chunk.dtor != cast(void())null) {
                            chunk.dtor();
                        }
                        std::free(chunk.ptr);
                        next = chunk.next;
                        this.allocations.remove(chunk.ptr,false);
                        chunk = next;
                    }
                }

                i += 1;
            }
            ~this.allocations;
        }

        void* malloc(int size, void() dtor) => this.allocate(0,size,dtor);
        void* calloc(int count, int size, void() dtor) => this.allocate(count,size,dtor);
        void* realloc(void* p, int size) {
            std::Alloc* alloc = this.allocations.get(p);

            void* toret;
            void* q;

            if((p != null) && (alloc != cast(std::Alloc*)null)) {
                q = null;
            }

            if(p == null) {
                std::Alloc* _alloc = this.allocations.put(q,size,cast(void())null);
                toret = _alloc.ptr;
            }
            else {
                toret = q;
                if(p == toret) alloc.size = size;
                else {
                    void() dtor = alloc.dtor;
                    this.allocations.remove(p,true);
                    this.allocations.put(toret,size,dtor);
                }
            }
        } => toret;

        void free(void* ptr) {
            std::Alloc* alloc = this.allocations.get(ptr);

            if(alloc != null) {
                if(alloc.dtor != cast(void())null) alloc.dtor();
                std::free(ptr);
                this.allocations.remove(ptr,true);
            }
        }
    }
}

namespace GC {
    
}