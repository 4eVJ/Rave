import <std/memory>

namespace libc {
    // Functions that are practically unnecessary in normal use and come from libc
    extern(linkname: "strlen") int strlen(char* cstr);
    char* btos(bool b) {
        char* toret = "true";
        if(b == false) toret = "false";
    } => toret;
}

namespace std {
    extern(linkname: "sscanf") int format(char* buff, char* fmt);
    struct string {
        char* data;
        int length;
        int capacity;

        std::string this(char* a) {
            this.length = libc::strlen(a);
            this.capacity = this.length*2;
            if(this.capacity == 0) this.capacity = 1;
            this.data = std::malloc(this.capacity);

            int i = 0;
            while(i<this.length) {
                this.data[i] = a[i];
                i += 1;
            }
            //this.data[i] = '\0';
        } => this;

        bool isDeleted => (this.data == null);
        char toChar => this.data[0];

        bool has(char c) {
            bool _has = false;

            int i = 0;
            while(i<this.length) {
                if(this.data[i] == c) {
                    _has = true;
                    i = this.length;
                }
                i += 1;
            }
        } => _has;

        char* c {
            char* temp = std::malloc(this.length+1);
            int i = 0;
            while(i<this.length) {temp[i] = this.data[i]; i += 1;}
            temp[i] = '\0';
            return temp;
        }

        int indexOf(char c) {
            int i = 0;
            int needed = -1;
            while(i<this.length) {if(this.data[i] == c) {needed = i; i = this.length;} i += 1;}
        } => needed;

        void append(char c) {
            this.length += 1;
            if(this.length == this.capacity) {
                this.capacity = this.capacity * 2;
                this.data = std::realloc(this.data,this.capacity);
            }
            this.data[this.length-1] = c;
        }

        void append(std::string str) {
            int i = 0;
            while(i<str.length) {
                this.append(str.data[i]);
                i += 1;
            }
        }

        void append(char* cstr) {
            int i = 0;
            while(cstr[i] != '\0') {
                this.append(cstr[i]);
                i += 1;
            }
        }

        std::string copy {
            std::string cp = std::string("");

            int i = 0;
            cp.append(*this);
        } => cp;

        std::string replace(char c, char to) {
            std::string temp = this.copy();

            int i = 0;
            while(i<this.length) {
                if(this.data[i] == c) {
                    temp.data[i] = to;
                }
                i += 1;
            }
        } => temp;

        std::string operator+(std::string one, std::string two) {
            std::string third = std::string(one.c());
            third.append(two);
        } => third;

        bool compare(std::string another) {
            bool isEqual = true;
            if(this.length != another.length) {
                isEqual = false;
            }
            else {
                int i = 0;
                while(i<another.length) {
                    if(this.data[i] != another.data[i]) isEqual = false;
                    i += 1;
                }
            }
        } => isEqual;

        bool compare(char* another) {
            bool isEqual = true;
            int len = libc::strlen(another);

            if(this.length != len) {
                isEqual = false;
            }
            else {
                int i = 0;
                while(i<len) {
                    if(this.data[i] != another[i]) isEqual = false;
                    i += 1;
                }
            }    
        } => isEqual;

        bool operator==(std::string one, std::string two) => one.compare(two);
        bool operator==(std::string one, char* two) => one.compare(two);
        bool operator!=(std::string one, std::string two) => !(one.compare(two));
        bool operator!=(std::string one, char* two) => !(one.compare(two));

        void operator=(std::string* one, char* two) {
            one[0] = std::string(two);
        }

        std::string substring(int from, int to) {
            std::string temp = "";

            int i = from;
            while(i<to) {
                temp.append(this.data[i]);
                i += 1;
            }
        } => temp;

        void ~this {
            std::free(this.data);
        }
    }
}

macro S {
    return std::string(#0);
}